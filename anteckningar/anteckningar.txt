WSL saker
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ubonto path: \\wsl$\Ubunt 

source ~/.bashrc
source ~/.profile

gcc riscx path: /opt/riscv/bin         

BINDING USBBLASTER:
1) usbipd.exe attach --wsl --busid 1-1
2) lsusb 


java -jar rars1_6.jar
java -jar logisim-evolution-<version>-all.jar 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


RISC-V saker
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

if statemetn 

if(s==t)
    a = s;
a = a – t;

bne s0, t0, L1
add a0, s0, zero
L1: sub a0, a0, t0
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
if else statment 

if(s!=t)
    a = s;
else
    a = s + t;
a = a – t;

beq s0, t0, else   // if s0==t0, go to else, if s0!=t0, execute next instruction (add)
add a0, s0, zero
j L1
else:
add a0, s0, t0
L1:
sub t0, a0, s1
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
conditional loops 

int sum = 0;
for(int i=1; i < 10; i++)
sum = sum + i;

addi s1, zero, 0 # sum = 0    
addi s0, zero, 1 # i = 1
addi t0, zero, 10 # t0 = 10
for:                                    //beginning of the loop
bge s0, t0, done # i >= 10?             //end loop condition
add s1, s1, s0 # sum = sum + i          //code inside for loop
addi s0, s0, 1 # i = i + 1              //increase for iterator i
j for # repeat loop                     //start a new iteration 
done:

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Functions in Assembly

int main(){
    int y;
    y = sum(3,8);
    ...
}
int sum(int x, int y){
    return x + y;
}

.global sum
main:
    addi a0, zero, 3
    addi a1, zero, 8
    jal sum
    add s0, a0, zero
    ...
sum:
    add a0, a0, a1
    jr ra
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Arrays and Memory Access 
fattar inte direkt lol 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

twos complement
for negative: invert add 1

Sign Extension
spamma MSB tills alla bits är fyllda

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
instruction formats

R-Type (register-type) instructions have three register
operands: two sources and one destination

I-Type (immediate-type) instructions have two
register operands and one immediate operand

A few I-Type instructions are encoded slightly
differently, but are still considered I-Type. These are
shift immediate instructions (srli, slli, srai).

S-Type (immediate-type) instructionshave two register
operands and one immediate operand. 
e.g. sw

B-Type (branch-type,e.g., beq) instructions
have two registeroperands and one immediate operand.

U-Type (branch-type) instructions have one
destination register and a large immediate value.
In our system: lui

J-Type (e.g., jal) instructions have one
destination register and a large immediate value
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////